\newsection
\section{Технический проект}

\subsection{Общие сведения о программной системе}
Необходимо спроектировать и разработать распределенную систему для поиска информации по документам из Интернет-пространства.

Системе на вход подается некоторое множество адресов WEB-ресурсов.
Предполагается, что пространство документов связное и что через данное множество ресурсов достижимы все остальные документы целевого графа, чтобы система в перспективе своей работы могла бы целиком обработать пространство документов, которое соответствует начальному множеству.

Ключевыми компонентами системы будут являться:
\begin{itemize}
\item поисковый робот;
\item индексатор;
\item поисковик.
\end{itemize}

Компоненты имеют кардинально разные требования по функциональности и режимам работы, поэтому должны быть спроектированы независимо друг от друга для достижения низкой связанности и возможности горизонтального масштабирования системы.

Целью разработки данной распределенной программной системы является создание инструмента для эффективного ориентирования в таком быстрорастущем сегменте хранения информации как Интернет.

\subsection{Обоснование выбора технологий проектирования}
Используемые для создания программно-информационной системы
языки и технологии отвечают современным практикам разработки, позволяют достичь высокой производительности и отказоустойчивости системы.

\subsubsection{Язык программирования C++}

Язык программирования C++ является мультипарадигменным компилируемым языком со статической типизацией. Его основные преимущества заключаются в высокой производительности, гибкости, тесной связи с аппаратным обеспечением и поддержкой самых разнообразных конструкций из ООП. Эффективность всех компонентов системы будет зависеть от степени задержки выполняемых операций, поэтому С++ можно считать оптимально подходящим под запросы разработки.

\subsubsection{CMake}

CMake - это кроссплатформенная утилита, автоматизирующая процесс создания файлов сборки для таких компилируемых языков, как C++. В частности, в ОС GNU Linux она генерирует Makefile, который, как известно, ответственен за сборку всех имеющихся исходных файлов в один исполняемый. 

\subsubsection{PostgreSQL}

PostgreSQL выбрана в качестве основной базы данных за её мощные возможности и надежность в работе с большими объемами данных, а также поддержку сложных запросов и транзакций. PostgreSQL предлагает удобные функции для разработчиков, такие как поддержка массивов, храненимых процедур и функций, триггеров, что делает её идеальной для комплексных приложений, требующих масштабируемости и гибкости.

\subsubsection{RabbitMQ} 
RabbitMQ, система управления очередями сообщений, реализующая открытый протокол передачи сообщений AMQP, играет ключевую роль в обеспечении асинхронной обработки данных и интеграции различных частей системы. Эффективное использование RabbitMQ позволяет распределить нагрузку, улучшить производительность приложения и обеспечить надежную обработку сообщений. Аппаратное обеспечение должно соответствовать требованиям по пропускной способности и скорости обработки сообщений, что особенно важно при больших объемах данных.

\subsubsection{Библиотека Boost}

Библиотека Boost является сборником большого множества прикладных и востребованных библиотек на языке С++. Как правило, ни одно крупное приложение, где язык C++ является основным в стеке разработки, не обходится без этой библиотеки.
 
\subsubsection{Библиотека LibCDS}

Библиотека LibCDS (concurrent data structures) - достаточно известная в узких кругах библиотека lock-free (без блокировок) структур данных и алгоритмов. Её выбор обусловлен тем, что практически все программные компоненты предполагают многопоточную работу с данными и многие их них буду разделяться между нитями. Традиционные примитивы синхронизации, как правило, очень неэффективны при большом количестве потоков и при частом вызове, поэтому для повышения производительности системных компонентов было принято решение прибегнуть к структурам данных, свободных от блокировок.

\subsubsection{Библиотека IntelTBB}

Библиотека IntelTBB(Threading Building Blocks) - кроссплатформенная библиотека шаблонов C++, разработанная компанией Intel для параллельного программирования. Библиотека содержит алгоритмы и структуры данных, позволяющие программисту избежать многих сложностей, возникающих при использовании традиционных реализаций потоков. В рамках разработки она нужна будет во много ради Flow Graph. Эта часть библиотеки предоставляет такую абстракцию, как вычислительный граф, где на узлах происходит обработка, а через ребра передаются данные. Можно считать, что она является реализацией паттерна проектирования "<Цепочка обязанностей">, но при этом каждый её элемент по умолчанию имеет возможность для конкурентного исполнения под управлением глобального планировщика потоков. Такой подход будет полезен при проектировании и разработке индексатора.

\subsubsection{Библиотека Libpqxx}

Библиотека Libqpxx - библиотека на C++, написанная поверх библиотеки на языке C libpq, предоставляющая удобные ООП-абстракции для синхронной работы с базой данных PostgreSQL.

\subsubsection{Библиотека AMQP-CPP}

Библиотека AMQP-CPP - библиотека на C++, написанная поверх библиотеки на языке C libamqp, предоставляющая удобные ООП-абстракции для асинхронной работы с брокером сообщений RabbitMQ.

\subsubsection{Библиотека Yaml-Cpp}

Библиотека Yaml-Cpp - библиотека на C++, реализующая синтаксический анализ документов в формате YAML и предоставляющая удобный интерфейс для их чтения и записи. Так как все компоненты системы будут иметь конфигурационные файлы в формате YAML, она бесспорно будет очень полезна.

\subsubsection{Библиотека Cld3}

Библиотека Cld3 - библиотека, созданная и выложенная в открытый доступ компанией Google, предоставляющая обученную нейронную сеть для идентификации языка поданного на вход текстового фрагмента. Она будет полезна в рамках анализа текстовых запросов от пользователей в поисковике.

\subsubsection{Библиотека Libarchive}

Библиотека Libarchive - библиотека, написанная на языке С, предоставляющая средства чтения и записи данных в разных форматах сжатия и архивации.

\subsubsection{Библиотека Gumbo}

Библиотека Gumbo - библиотека на языке C, созданная и выложенная в открытый доступ компанией Google, предоставляющая готовый синтаксический анализатор HTML-документов. Так как наша система ориентирована для анализа документов из Интернета, то анализ HTML-документов должен быть одной из важных задач. 

\subsubsection{Библиотека Libstemmer}

Библиотека Libstemmer - библиотека на языке C, предоставляющая возможность производить операцию стемминга над словами с разделением по языкам, где стемминг - процесс нахождения основы слова для заданного исходного слова. Это будет необходимо для нахождения разделения всего абстрактного множества слов на классы эквивалентности, чтобы тем самым увеличить эффективность поиска. 

\subsubsection{Библиотека RobotsTxt}

Библиотека RobotsTxt - библиотека на языке C++, созданная и выложенная в открытый доступ компанией Google, предоставляющая готовый синтаксический анализатор документов, соответствующих стандарту REP (Robots Exclusion Protocol) - соглашения, которое разрешает владельцам Интернет-ресурсов определять ограничения для посещения страниц поисковыми роботами. Чтобы робот из нашей системы мог считаться "<вежливым">, необходимо иметь поддержку этого протокола в системе.

\subsubsection{Библиотека Quill}
Библиотека Quill - библиотека на языке C++, которая предоставляет средства для высокопроизводительного и гибкого создания журналируемых сообщений, последующий анализ которых позволит делать выводы о качествах работы тех или иных компонентов, что поможет в более прозрачном виде отслеживать ошибки и сбои.

\subsubsection{Библиотека Drogon}
Библиотека Drogon - кроссплатформенная библиотека на языке C++ для создания WEB-приложений. Она предоставляет множество ООП-абстракций, предоставляет полную поддержку асинхронных операций и имеет высокую производительность. Она будет нужна при создании поисковика.

\subsection{Архитектура распределенной системы}

Распределенная система будет представлена набором сервисов с независимыми моделями данных, которые будут взаимодействовать друг с другом посредством брокера сообщений. Подобную структуру можно отнести к классу микросервисных архитектур.

Система будет представлена следующими сервисами:
\begin{itemize}
\item поисковый робот;
\item индексатор;
\item поисковик;
\item сборщик журналируемой информации, поступающей от вышеперечисленных сервисов.
\end{itemize}

Роль брокера сообщений будет исполнять RabbitMQ.

На рисунке 3.1 представлена диаграмма развертывания распределенной поисковой системы.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{diagram_deployment}}
\caption{Диаграмма развертывания распределенной поисковой системы}
\label{diagram_deployment:image}
\end{figure}

\subsection{Поисковый робот}

Поисковый робот предназначен для обхода в ширину веб-графа, которым представлен Интернет. Он сохраняет метаинформацию о документах в базе данных до следующего обхода и переходит по их ссылкам с целью нахождения новых документов на заданном пространстве. После успешной валидация документ отправляется на шину данных для дальнейшей обработки другими компонентами, в частности, индексатором. 

\subsubsection{Типы обрабатываемых документов}
Робот при работе с ресурсами Интернета будет иметь дело со следующими типами документов:
\begin{itemize}
\item файл robots.txt, содержимое которое соответствует протоколу REP, не индексируется;
\item файлы навигации по веб-ресурсу в формате XML, содержимое которых соответствует протоколу SITEMAP, могут быть вложенными, не индексируются;
\item рядовые HTML-документы, которые должны быть проиндексированы системой и порождаются либо корневой страницей веб-ресурса, либо файлами навигации SITEMAP.
\end{itemize}

\subsubsection{Компоненты поискового робота}

На рисунке 3.2 представлена диаграмма компонентов поискового робота.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{robot/diagram_components}}
\caption{Диаграмма компонентов поискового робота распределенной системы}
\label{robot/diagram_components:image}
\end{figure}

\subsubsection{Описание базы данных}

На рисунке 3.3 представлена ER-диаграмма базы данных поискового робота.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{robot/robot_db}}
\caption{ER-диаграмма базы данных поискового робота распределенной системы}
\label{robot/robot_db:image}
\end{figure}

\subsubsection{Описание потоков данных}

На рисунке 3.4 представлена диаграмма потоков данных для поискового робота распределенной системы.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{robot/diagram_dataflow}}
\caption{Диаграмма потоков данных для поискового робота распределенной системы}
\label{robot/diagram_dataflow:image}
\end{figure}

\subsubsection{Описание концептуальных классов}

На рисунке 3.5 представлена диаграмма концептуальных классов для поискового робота распределенной системы.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{robot/diagram_classes}}
\caption{Диаграмма концептуальных классов для поискового робота распределенной системы}
\label{robot/diagram_classes:image}
\end{figure}

\subsection{Индексатор}

Индексатор - компонент системы, ответственный за статический анализ полученных им документов, результаты которого впоследствии будут использоваться в режиме чтения поисковиком. 
При проектировании и разработке индексатора сосредоточимся на следующих главных задачах:
\begin{itemize}
\item обеспечение контроля сбора ресурсов из брокера сообщений;
\item разработка алгоритма индексирования документов;
\item разработка алгоритма вычисления статического ранга документов.
\end{itemize}

\subsubsection{Описание контроля сбора ресурсов}
Контроль сбора ресурсов будет включать в себя следующие обязательные аспекты:
\begin{itemize}
\item ограничение количества ресурсов для индексирования. После предварительной обработки некоторого натурального числа документов сбор новых прекращается и начинаются следующие стадии индексации;
\item парциальный сбор ресурсов. Ввиду того, что предварительная индексация ресурса выполняется намного дольше, чем его получение из очереди сообщений, разумно делать это парциально, чтобы в конечном итоге не перегрузить оперативную память. По этой причине индексатору будет задаваться размер порции ресурсов для обработки и желаемая скорость в единицах в секунду;
\end{itemize}

\subsubsection{Индексирование документов}

Логической моделью проиндексированных документов будет являться инвертированный индекс. 

Инвертированный индекс - индекс, который представляет собой хеш-таблицу следующей конфигурации: 
\begin{itemize}
\item ключом является термин, как правило, его глобальный целочисленный индентификатор;
\item значение же представляется в виде списка глобальных идентификаторов документов, в которых данный термин был встречен хотя бы один раз.
\end{itemize}

Однако одной лишь структуры мало. Терминов в одном документе может быть много, поэтому необходимо для каждого из них рассчитать их относительный ранг, находящийся в диапазоне от 0 до 1 включительно. Этот ранг будет вычисляться на основе абсолютной взвешенной частоты термина и его обратной документной частоты.

Кроме того, в целях повышения производительности системы организуем индекс так, чтобы поиск по нему мог осуществляться нечетко, но с минимальными потерями в точности и полноте поиска. Этого можно достичь с использованием так называемых "<чемпионских списков">.

Чемпионские списки представляют из себя хеш-таблицу, где ключом выступает целочисленный идентификатор термина, а значением - ограниченный в размере список идентификаторов документов, расположенных по убыванию, начиная с документа, в котором заданный термин имеет максимальный относительный ранг. 

\paragraph{Абсолютная взвешенная частота термина}

Абсолютная взвешенная частота функционально зависит от количество вхождений термина в документ. Но так как мы зачастую будем иметь дело с форматами данных древовидной структуры, таких как HTML, мы можем дополнительно присваивать каждому типу узла свой вес $w$. Кроме того, чтобы учитывать вложенность узлов, необходимо ввести агрегирующую весовую функцию $Agg$. Итак, полная формула вычисления абсолютной взвешенной частоты термина в документе принимает следующий вид:

\begin{center}
$WTF(t) = \sum_{i = 1}^{n}Agg(w_1, w_2, ..., w_m)$
\end{center} где $n$ -- количество вхождений термина данных, а $m$ -- количество взвешенных предков-узлов элемента, в содержание текста которого входит термин $t$.

Смысл абсолютной взвешенной частоты термина достаточно прост. Чем чаще термин встречается в документе, тем выше его последующий ранг. Однако нередки случаи, когда высокая внутридокументная частота термина обусловлена лишь тем, что этот термин входит в число частоиспользуемых. Чтобы снизить влияние данного фактора, вводится понятие обратной документной частоты термина.

\paragraph{Обратная документная частота термина}

Документная частота термина ($DTF$) - количество документов, в которых термин был встречен хотя бы один раз. Обратная документная частота же определяется следующим образом:

\begin{center}
$IDTF(t) = \log\frac{N}{DTF(t)}$
\end{center} где $N$ -- общее количество документов, $DTF(t)$ -- документная частота термина $t$.

Смысл обратной документной частоты заключается в том, что в случае, если термин встречается в большом количестве документов, то независимо от $WTF$ ранг термина будет снижен.

\paragraph{Относительный ранг термина в документе}

Абсолютный ранг термина в документе вычисляется следующим образом:
\begin{center}
$ATR(t) = WTF(t) * IDTF(t)$
\end{center}

В свою очередь, относительный ранг термина вычисляется путем нормализации её абсолютных вариаций:
\begin{center}
$RTR(t) = \frac{ATR(t)}{\sqrt(\sum{i = 1}^{n}ATR(t_1)^2 + ATR(t_2)^2 + ... + ATR(t_m)^2)}$
\end{center} где $m$ -- количество различных терминов в документе.

\subsubsection{Статическое ранжирование документов}

С целью повышения релевантности поисковой выдачи необходимо учитывать конфигурацию веб-графа документов в целом. Поэтому разумно каждому документы присвоить некоторый относительный ранг, который будет зависеть от количества и качества входящих и исходящих ссылок. Интуитивно очевидно, что ранг документа должен быть выше, если выше вероятность перехода на него по гиперссылке. В таком случае мы можем представить документы, как состояния марковской цепи. 

Марковская цепь -- это дискретный стохастический процесс, представляющий собой последовательность временных шагов, на каждом из которых происходит случайн выбор независимо от предыдущего.

Марковская цепь характеризуется матрицей вероятностей переходов $P$, имеющей размерность $N$ x $N$, где $N$ - количество состояний цепи. Сумма элементов в строке матрицы переходов должна равняться 1. В таком случае $P(i, j)$ - вероятность перехода с $i$-ой страницы на $j$-ую.

Матрица с неотрицательными элементами называется стохастической. Ключевое её свойство заключается в том, что она имеет главный левый собственный вектор, соответствующий максимальному значению, которое равно единице.

Также введем определение эргодической марковской цепи.

Марковская цепь называется эргодической, если существует положительное целове число $T_0$, такое. что для всех пар состояний $i$, $j$ в марковской цепи, стартующей в момент $t = 0$ из состояния $i$, для всех $t > T_0$ вероятность нахождения в момент времени $t$ в состоянии $j$ больше нуля.

Иными словами для эргодической марковской цепи должны быть выполнены следующие условия:
\begin{itemize}
\item неразложимость -- гарантирует, что существует последовательность переходов с ненулевой вероятностью из любого состояния в любое другое;
\item апериодичность -- гарантирует, что состояния не делятся на такие множества, что все переходы осуществляются циклически из состояний одного множества в состояния другого множества;
\end{itemize}

И, наконец, для любой эргодической цепи верно следующее утверждение.

Для любой эргодической цепи Маркова существует единственный вектор стационарного распределения вероятностей $\vec{p}$, являющийся главным левым собственным вектором матрицы $P$, и если $f(i, t)$ -- количество переходов в состоянии $i$ за $t$ шагов, то 

\begin{center}
$lim_{t \to \inf}\frac{f(i, t)}{t}=p(i)$
\end{center} где $p(i) > 0$ -- стационарная вероятность состояния $i$.

Чтобы воспользоваться вышеописанное теоретической выкладкой, сформируем модель обхода документов.

Пусть есть некоторый абстрактный "<путешественник">, который в случайном порядке переходит со страницы на страницу.
Определим два несовместных типа переходов:
\begin{itemize}
\item стационарный переход с одной страницы на другую по гиперссылке, который имеет свою вероятностную оценку;
\item телепортация с постоянной вероятностью $\alpha$ c одной страницы на другую не задействуя гиперссылки. Такая возможность сделает нашу марковскую цепь эргодической.
\end{itemize}

Итак, формула полной вероятности перехода с $i$-ой страницы на $j$-ую будет иметь вид:

\begin{center}
$P(i, j) = \frac{1}{L_i} * (1 - \alpha) + \frac{1}{N} * \alpha$
\end{center} где $L_i$ -- количество ненулевых элементов матрицы смежности веб-графа на строке $i$, $N$ -- общее количество документов.

На основе этой формулы мы формируем матрицу в ероятностных переходов марковской эргодической цепи и итеративно приближенно вычисляем её левый собственный вектор, который будет являться стационарным распределением вероятностей между всеми документами из множества, что мы и будем называть статическим рангом документа.

\subsubsection{Компоненты индексатора}

На рисунке 3.6 представлена диаграмма компонентов индексатора.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{indexer/diagram_components}}
\caption{Диаграмма компонентов индексатора распределенной поисковой системы}
\label{indexer/diagram_components:image}
\end{figure}

\subsubsection{Описание базы данных}

Модель данных будет состоять из двух логических частей, физически расположенных в одной базе:
\begin{enumerate}
\item Эталонная часть модели, предназначенная исключительно для чтения поисковиком при обработке пользовательских запросов;
\item Черновая часть модели, предназначенная для создания новых версий индекса, не вмешиваясь во внутреннюю структуру эталонной модели. Она содержит в себе полную копию структуры эталонной модели с несколькими дополнениями, необходимыми для эффективного создания индекса. После завершения создания черновой модели она атомарно целиком заменяет эталонную, при этом полностью очищаясь для создания следующего экземпляра индекса.
\end{enumerate}

На рисунках 3.7 - 3.8 представлены ER-диаграммы эталонной и черновой части базы данных индекса распределенной системы.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{indexer/indexer_sec_db}}
\caption{ER-диаграмма черновой части базы данных индексатора распределенной системы}
\label{indexer/indexer_sec_db:image}
\end{figure}

\begin{figure}
\center{\includegraphics[width=1\linewidth]{indexer/indexer_db}}
\caption{ER-диаграмма эталонной части базы данных индексатора распределенной системы}
\label{indexer/indexer_db:image}
\end{figure}

\subsubsection{Описание концептуальных классов}

На рисунке 3.9 представлена диаграмма концептуальных классов для индексатора распределенной системы.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{indexer/diagram_classes}}
\caption{Диаграмма концептуальных классов для индексатора распределенной системы}
\label{indexer/diagram_classes:image}
\end{figure}

\subsection{Поисковик}

Поисковик предназначен для обработки пользовательских запросов и выдачи релеватных результатов поиска с помощью ранее созданного индекса документов.

\subsubsection{Описание процесса ранжирования документов}

Начнем с того, что заметим, что количество всех веб-документов хоть и велико, но ограничено некоторым натуральным числом. По этой причине количество возможных терминов также ограничено некоторым натуральным числом $T$. 

Следовательно, множество всех веб-документов можно рассмотреть, как конечное векторное пространство размерности $T$. 

В свою очередь, каждый документ определяется некоторым вектором
\begin{center}
$\vec{D}=(r_1, r_2, ..., r_T)$
\end{center} где $r_i$ -- относительный ранг термина с номером $i$ в документе $D$.

Мерой соответствия одного документа другому можно считать косинус угла между их векторами в вышеопределенном векторном пространстве, а именно следующее:

\begin{center}
$R(d_1, d_2)=\frac{\vec{d_1} * \vec{d_2}}{|\vec{d_1}| |\vec{d_2}|}$
\end{center} где $R$ -- мера соответствия документа $d_1$ документу $d_2$ и наоборот.

Пользовательский запрос будет рассматриваться системой как документ, так как фактически тоже имеет своё текстовое значение и определенную смысловую нагрузку. Поэтому для получения меры соответствия запроса какому-либо документу, будет необходимо получить вектор запроса и найти значение косинуса угла между ним и вектором целевого документа.

\subsubsection{Описание алгоритма работы поисковика}
Алгоритм работы поисковика состоит в следующем:
\begin{enumerate}
\item Анализ и разбиение возможного мультиязычного пользовательского запроса на множество отрывков с одинаковым языком. В зависимости от вероятности соответствия предсказанного языка к отрывку присвоить каждому из них свой первоначальный ранг. Добиться подобного функционала можно с использованием нейросетей.
\item С помощью парсера свободных текстовых запросов разбить отрывки на множество лексем в соответствие с правилами. В рамках данной работы предполагаются следующие действия:
\begin{itemize}
\item фильтрация стоп-слов (часто употребимых слов для каждого языка, которые не несут существенной смысловой нагрузки);
\item операция стемминга для присвоения каждой лексемы к конкретному классу эквивалентности.
\end{itemize}
\item Объединить множества лексем из всех отрывков в один большой поток токенов. Пользовательский запрос будет рассматриваться как документ, поэтому каждый токен будет иметь свою взвешенную частотную характеристику, название языка и непосредственно значение. Так как документ всего один - запрос, то в этом случае взвешенная частотная характеристика совпадает с абсолютным рангом токена. По этой причине остается провести лишь операцию нормализации рангов, с целью для каждого термина получить относительный ранг.
\item Получив векторное представление пользовательского запроса, для каждого его термина найдем чемпионские списки и объединим их, получив в конечном итоге целевое множество документов для поиска.
\item Для каждого документа находится косинусная мера его соответствия пользовательскому запросу. По итогу для каждого документа мы имеем $\vec{R}$, у которого есть две составляющие: косинусная мера соответствия запросу (динамическая) и ранг (статическая).
\item С помощью заданного коэффициента приоритета статического критерия над динамическим объединяем две составляющие через нахождение длины $\vec{R}$, будем считать это релевантностью документа.
\item Сортируем документы по убыванию релевантности и отправляем заголовок, URL и релевантность документа в соответствие с заданными параметрами смещения и количества.
\end{enumerate}

\subsubsection{Компоненты поисковика}

На рисунке 3.10 представлена диаграмма компонентов поисковика.

\begin{figure}
\center{\includegraphics[width=1\linewidth]{searcher/diagram_components}}
\caption{Диаграмма компонентов поисковика распределенной поисковой системы}
\label{searcher/diagram_components:image}
\end{figure}